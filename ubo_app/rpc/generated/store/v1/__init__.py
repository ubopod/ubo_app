# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: store/v1/store.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto
import grpclib
import grpclib.server
from betterproto.grpc.grpclib_server import ServiceBase

from ...ubo import v1 as __ubo_v1__

if TYPE_CHECKING:
    from collections.abc import AsyncIterator

    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class DispatchActionRequest(betterproto.Message):
    action: '__ubo_v1__.Action' = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DispatchEventRequest(betterproto.Message):
    event: '__ubo_v1__.Event' = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DispatchActionResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DispatchEventResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SubscribeEventRequest(betterproto.Message):
    event: '__ubo_v1__.Event' = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class SubscribeEventResponse(betterproto.Message):
    event: '__ubo_v1__.Event' = betterproto.message_field(1)


class StoreServiceStub(betterproto.ServiceStub):
    async def dispatch_action(
        self,
        dispatch_action_request: 'DispatchActionRequest',
        *,
        timeout: 'float | None' = None,
        deadline: 'Deadline | None' = None,
        metadata: 'MetadataLike | None' = None,
    ) -> 'DispatchActionResponse':
        return await self._unary_unary(
            '/store.v1.StoreService/DispatchAction',
            dispatch_action_request,
            DispatchActionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def dispatch_event(
        self,
        dispatch_event_request: 'DispatchEventRequest',
        *,
        timeout: 'float | None' = None,
        deadline: 'Deadline | None' = None,
        metadata: 'MetadataLike | None' = None,
    ) -> 'DispatchEventResponse':
        return await self._unary_unary(
            '/store.v1.StoreService/DispatchEvent',
            dispatch_event_request,
            DispatchEventResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_event(
        self,
        subscribe_event_request: 'SubscribeEventRequest',
        *,
        timeout: 'float | None' = None,
        deadline: 'Deadline | None' = None,
        metadata: 'MetadataLike | None' = None,
    ) -> 'AsyncIterator[SubscribeEventResponse]':
        async for response in self._unary_stream(
            '/store.v1.StoreService/SubscribeEvent',
            subscribe_event_request,
            SubscribeEventResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class StoreServiceBase(ServiceBase):

    async def dispatch_action(
        self, dispatch_action_request: 'DispatchActionRequest',
    ) -> 'DispatchActionResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def dispatch_event(
        self, dispatch_event_request: 'DispatchEventRequest',
    ) -> 'DispatchEventResponse':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_event(
        self, subscribe_event_request: 'SubscribeEventRequest',
    ) -> 'AsyncIterator[SubscribeEventResponse]':
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SubscribeEventResponse()

    async def __rpc_dispatch_action(
        self,
        stream: 'grpclib.server.Stream[DispatchActionRequest, DispatchActionResponse]',
    ) -> None:
        request = await stream.recv_message()
        response = await self.dispatch_action(request)
        await stream.send_message(response)

    async def __rpc_dispatch_event(
        self,
        stream: 'grpclib.server.Stream[DispatchEventRequest, DispatchEventResponse]',
    ) -> None:
        request = await stream.recv_message()
        response = await self.dispatch_event(request)
        await stream.send_message(response)

    async def __rpc_subscribe_event(
        self,
        stream: 'grpclib.server.Stream[SubscribeEventRequest, SubscribeEventResponse]',
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_event,
            stream,
            request,
        )

    def __mapping__(self) -> 'dict[str, grpclib.const.Handler]':
        return {
            '/store.v1.StoreService/DispatchAction': grpclib.const.Handler(
                self.__rpc_dispatch_action,
                grpclib.const.Cardinality.UNARY_UNARY,
                DispatchActionRequest,
                DispatchActionResponse,
            ),
            '/store.v1.StoreService/DispatchEvent': grpclib.const.Handler(
                self.__rpc_dispatch_event,
                grpclib.const.Cardinality.UNARY_UNARY,
                DispatchEventRequest,
                DispatchEventResponse,
            ),
            '/store.v1.StoreService/SubscribeEvent': grpclib.const.Handler(
                self.__rpc_subscribe_event,
                grpclib.const.Cardinality.UNARY_STREAM,
                SubscribeEventRequest,
                SubscribeEventResponse,
            ),
        }
